// git_watcher.cmake
// https://raw.githubusercontent.com/andrew-hardin/cmake-git-version-tracking/master/git_watcher.cmake
//
// Released under the MIT License.
// https://raw.githubusercontent.com/andrew-hardin/cmake-git-version-tracking/master/LICENSE

#include "chyps/git.hpp"

namespace chyps {

std::string GetGitDescriptionString(void) {
  std::string description;
  if (GitMetadata::Populated()) {
    description += "Git Commit SHA1: " + GitMetadata::CommitSHA1() + '\n';
    description += "Git Commit Date: " + GitMetadata::CommitDate() + '\n';
    description += "Git Commit Describe: " + GitMetadata::Describe();
    if (GitMetadata::AnyUncommittedChanges()) {
      description +=
          "\nWARNING: Directory is dirty. There are uncommitted changes.";
    } else {
      description += "\nDirectory is clean. No uncommitted changes.";
    }
  } else {
    description = "No git information found. Is this a git repository?";
  }
  return description;
}

// clang-format off
bool GitMetadata::Populated() { return @GIT_RETRIEVED_STATE@; }
bool GitMetadata::AnyUncommittedChanges() { return @GIT_IS_DIRTY@; }
std::string GitMetadata::AuthorName() { return "@GIT_AUTHOR_NAME@"; }
std::string GitMetadata::AuthorEmail() { return "@GIT_AUTHOR_EMAIL@"; }
std::string GitMetadata::CommitSHA1() { return "@GIT_HEAD_SHA1@"; }
std::string GitMetadata::CommitDate() { return "@GIT_COMMIT_DATE_ISO8601@"; }
std::string GitMetadata::CommitSubject() { return "@GIT_COMMIT_SUBJECT@"; }
std::string GitMetadata::CommitBody() { return @GIT_COMMIT_BODY@; }
std::string GitMetadata::Describe() { return "@GIT_DESCRIBE@"; }
// clang-format on

}  // namespace chyps
